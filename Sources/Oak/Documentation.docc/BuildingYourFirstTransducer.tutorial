@Tutorial(time: 20) {
    @Intro(title: "Building Your First Transducer") {
        
        Learn how to create a simple state machine using Oak's Transducer protocol. You'll build a counter that can increment, decrement, and reset its value.
        
        @Image(source: "oak-logo.png", alt: "Oak Framework Logo")
    }
    
    @Section(title: "Create the Basic Structure") {
        @ContentAndMedia {
            Every Oak transducer starts with defining your state and events. Think of state as "what situation is my app in?" and events as "what can happen to change that situation?"
            
            @Image(source: "transducer-overview.png", alt: "Transducer State and Events Overview")
        }
        
        @Steps {
            @Step {
                Create a new Swift file and define your transducer enum that conforms to the `Transducer` protocol.
                
                @Code(name: "SimpleCounter.swift", file: "tutorial-step1.swift")
            }
            
            @Step {
                Define the possible states your counter can be in. For a simple counter, we only need one state that holds the current count value.
                
                @Code(name: "SimpleCounter.swift", file: "tutorial-step2.swift")
            }
            
            @Step {
                Define the events that can happen to your counter. These represent all the ways users can interact with your state machine.
                
                @Code(name: "SimpleCounter.swift", file: "tutorial-step3.swift")
            }
            
            @Step {
                Specify the output type. This is what your transducer will produce when state changes occur.
                
                > Important: When your transducer's `update` function returns an output value (not `Void`), you **must** declare the `Output` typealias. This is required by Oak's protocol design to ensure type safety.
                
                @Code(name: "SimpleCounter.swift", file: "tutorial-step4.swift")
            }
        }
    }
    
    @Section(title: "Implement the Update Function") {
        @ContentAndMedia {
            The `update` function is the heart of your transducer. It defines exactly what happens for every possible combination of current state and incoming event.
            
            This is where Oak's power shines: **every possible situation is explicitly handled**, eliminating undefined behavior.
        }
        
        @Steps {
            @Step {
                Add the initial state. This defines what state your transducer starts in when first created.
                
                @Code(name: "SimpleCounter.swift", file: "tutorial-step5.swift")
            }
            
            @Step {
                Implement the update function signature. This function receives the current state (which you can modify) and an event, then returns output.
                
                @Code(name: "SimpleCounter.swift", file: "tutorial-step6.swift")
            }
            
            @Step {
                Handle the increment event. When the counter receives an increment event, increase the count and return the new value.
                
                @Code(name: "SimpleCounter.swift", file: "tutorial-step7.swift")
            }
            
            @Step {
                Handle the decrement event. Make sure the counter never goes below zero by using `max(0, count - 1)`.
                
                @Code(name: "SimpleCounter.swift", file: "tutorial-step8.swift")
            }
            
            @Step {
                Handle the reset event. This sets the counter back to zero regardless of its current value.
                
                @Code(name: "SimpleCounter.swift", file: "tutorial-step9.swift")
            }
        }
    }
    
    @Section(title: "Add Initial Output Support") {
        @ContentAndMedia {
            Oak supports Moore-style state machines where states can have output values even before any events are processed. This is useful when your transducer should produce meaningful output from its initial state.
        }
        
        @Steps {
            @Step {
                Implement the `initialOutput` function to provide output for the starting state.
                
                @Code(name: "SimpleCounter.swift", file: "tutorial-step10.swift")
            }
            
            @Step {
                Your complete transducer is now ready! The counter can increment, decrement, reset, and provides output for every state transition.
                
                @Code(name: "SimpleCounter.swift", file: "tutorial-step11.swift")
            }
        }
    }
    
    @Section(title: "Test Your Transducer") {
        @ContentAndMedia {
            Oak's deterministic design makes testing straightforward. Every state transition is predictable and reproducible.
        }
        
        @Steps {
            @Step {
                Create a simple test to verify your counter works correctly. Start with the initial state and send some events.
                
                @Code(name: "SimpleCounterTests.swift", file: "tutorial-test1.swift")
            }
            
            @Step {
                Test edge cases like decrementing below zero. Your transducer should handle these gracefully.
                
                @Code(name: "SimpleCounterTests.swift", file: "tutorial-test2.swift")
            }
            
            @Step {
                Verify that reset works from any state. This demonstrates the power of explicit state management.
                
                @Code(name: "SimpleCounterTests.swift", file: "tutorial-test3.swift")
            }
        }
    }
    
    @Section(title: "Next Steps") {
        @ContentAndMedia {
            Congratulations! You've built your first Oak transducer using the basic `Transducer` protocol. This tutorial covered the fundamentals with pure state transitions and simple testing.
            
            As you build more complex applications, you'll encounter scenarios requiring side effects like network requests, timers, or user interactions. Oak handles these through `EffectTransducer`, which builds upon everything you've learned here.
            
            When working with `EffectTransducer` and complex async flows, you'll explore more advanced testing patterns including effect verification, async flow testing with mock environments, SwiftUI integration testing, and error handling scenarios. The pure function approach you've mastered here provides the foundation for all these advanced scenarios.
        }
    }
}